package eu.vendeli.tgbot.types.chain

import eu.vendeli.tgbot.TelegramBot
import eu.vendeli.tgbot.types.User
import eu.vendeli.tgbot.types.component.ProcessedUpdate
import eu.vendeli.tgbot.types.component.getChat
import eu.vendeli.tgbot.utils.common.fqName
import eu.vendeli.tgbot.utils.common.safeCast
import kotlin.reflect.KClass

/**
 * Base class for wizard steps.
 * Each step defines entry behavior, validation, and optional state storage.
 */
abstract class WizardStep(
    val isInitial: Boolean = false,
) {
    /**
     * Unique identifier for this step, defaults to the fully qualified class name.
     */
    open val id: String = this::class.fqName

    /**
     * Called when entering this step.
     */
    abstract suspend fun onEntry(ctx: WizardContext)

    /**
     * Called when validation fails and the step should retry.
     */
    open suspend fun onRetry(ctx: WizardContext) = Unit

    /**
     * Validates the current input and decides what happens next.
     * Must return a [Transition] indicating the next action.
     */
    abstract suspend fun validate(ctx: WizardContext): Transition

    /**
     * Value to be persisted for this step (if any).
     * Return null if this step doesn't store state.
     */
    open suspend fun store(ctx: WizardContext): Any? = null
}

/**
 * Represents a transition from one wizard step to another.
 */
sealed class Transition {
    /**
     * Move to the next step in sequence.
     */
    object Next : Transition()

    /**
     * Jump to a specific step.
     */
    data class JumpTo(
        val step: KClass<out WizardStep>,
    ) : Transition()

    /**
     * Retry the current step (validation failed).
     */
    object Retry : Transition()

    /**
     * Finish the wizard.
     */
    object Finish : Transition()
}

/**
 * Context passed to wizard steps, containing all necessary information.
 */
class WizardContext(
    val user: User,
    val update: ProcessedUpdate,
    val bot: TelegramBot,
) {
    val userReference = UserChatReference(user.id, update.getChat().id)
    val currentWizardId = bot.inputListener.get(user.id)?.extractWizardId()
        ?: error("No active wizard for user ${user.id}")

    /**
     * Fallback method to get state for any step (returns Any?).
     * Type-safe methods are generated by KSP for each step.
     */
    suspend fun getState(step: KClass<out WizardStep>): Any? = getStateManagerForStep(step)?.get(step, userReference)

    /**
     * Fallback method to set state for any step.
     * Type-safe methods are generated by KSP for each step.
     */
    suspend fun setState(step: KClass<out WizardStep>, value: Any?) {
        if (value != null) getStateManagerForStep(step)?.set(step, userReference, value)
    }

    /**
     * Fallback method to delete state for any step.
     * Type-safe methods are generated by KSP for each step.
     */
    suspend fun delState(step: KClass<out WizardStep>) {
        getStateManagerForStep(step)?.del(step, userReference)
    }

    private fun getStateManagerForStep(step: KClass<out WizardStep>): WizardStateManager<Any>? {
        val wizardInst = bot.update.registry
            .getActivity(currentWizardId)
            .safeCast<WizardActivity>() ?: return null
        return wizardInst.getStateManagerForStep(step, bot).safeCast()
    }

    private companion object {
        private val WIZARD_REGEX = ":(-?\\d+):".toRegex()
        fun String.extractWizardId(): Int? = WIZARD_REGEX
            .find(this)
            ?.groupValues
            ?.get(1)
            ?.toInt()
    }
}
