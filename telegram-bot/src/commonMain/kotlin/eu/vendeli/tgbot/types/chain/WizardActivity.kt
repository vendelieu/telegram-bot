package eu.vendeli.tgbot.types.chain

import eu.vendeli.tgbot.TelegramBot
import eu.vendeli.tgbot.core.Activity
import eu.vendeli.tgbot.types.User
import eu.vendeli.tgbot.types.component.ProcessingContext
import eu.vendeli.tgbot.types.component.userOrNull
import eu.vendeli.tgbot.utils.common.fqName
import eu.vendeli.tgbot.utils.common.safeCast
import kotlin.reflect.KClass

/**
 * Abstract runtime executor for wizard flows.
 * Manages step transitions and state persistence using provided state managers.
 * Concrete implementations are generated by KSP.
 * Extends Activity to integrate with ActivityRegistry.
 */
abstract class WizardActivity : Activity {
    abstract val steps: List<WizardStep>

    /**
     * Gets the wizard ID from the activity ID.
     * Format: "wizard:${id}"
     */
    protected fun getWizardId(): String = "wizard:$id"

    /**
     * Resolves the appropriate state manager for a given step and its store return type.
     * Implementations should match the step's store() return type with the state manager's generic type.
     *
     * @param step The wizard step class
     * @param bot The bot instance to get state manager from
     * @return The matching state manager, or null if no manager is configured for this step
     */
    abstract fun getStateManagerForStep(
        step: KClass<out WizardStep>,
        bot: TelegramBot,
    ): WizardStateManager<out Any>?

    /**
     * Starts the wizard by entering the initial step.
     */
    suspend fun start(ctx: WizardContext) {
        val initial = steps.firstOrNull {
            it.isInitial
        } ?: steps.firstOrNull() ?: error("Wizard must have at least one step")
        enterStep(initial, ctx)
        setCurrentStep(ctx.user, ctx.bot, initial)
    }

    /**
     * Activity invoke implementation - handles wizard input.
     */
    override suspend fun invoke(context: ProcessingContext): Any? {
        val user = context.update.userOrNull ?: return Unit
        val wizardCtx = WizardContext(user, context.update, context.bot)

        return start(wizardCtx)
    }

    /**
     * Handles input for the current step.
     * Validates the input and transitions to the next step based on the result.
     * @return The new current step, or null if the wizard finished.
     */
    suspend fun handleInput(ctx: WizardContext): WizardStep? {
        val currentStep = getCurrentStep(ctx.user, ctx.bot)
            ?: error("No current step for user ${ctx.user.id}")

        return when (val transition = currentStep.validate(ctx)) {
            is Transition.Retry -> {
                currentStep.onRetry(ctx, transition.reason)
                currentStep
            }

            is Transition.Next -> {
                persist(currentStep, ctx)
                val next = nextOf(currentStep) ?: run {
                    ctx.bot.config.loggerFactory.get(this::class.fqName).debug(
                        "No next step for ${currentStep::class}",
                    )
                    return null
                }
                setCurrentStep(ctx.user, ctx.bot, next)
                enterStep(next, ctx)
                next
            }

            is Transition.JumpTo -> {
                persist(currentStep, ctx)
                val target = steps.find { it::class == transition.step }
                    ?: error("Unknown step: ${transition.step}")
                setCurrentStep(ctx.user, ctx.bot, target)
                enterStep(target, ctx)
                target
            }

            is Transition.Finish -> {
                persist(currentStep, ctx)
                finish(ctx)
                clearCurrentStep(ctx.user, ctx.bot)
                null
            }
        }
    }

    private suspend fun persist(step: WizardStep, ctx: WizardContext) {
        val value = step.store(ctx)
        if (value != null) {
            val manager = getStateManagerForStep(step::class, ctx.bot)

            // KSP ensures type matching at compile time
            manager?.safeCast<WizardStateManager<Any>>()?.set(step::class, ctx.userReference, value)
            // If no matching manager, silently skip (step doesn't need state)
        }
    }

    private suspend fun enterStep(step: WizardStep, ctx: WizardContext) {
        step.onEntry(ctx)
    }

    private fun nextOf(step: WizardStep): WizardStep? {
        val idx = steps.indexOf(step)
        return steps.getOrNull(idx + 1)
    }

    private suspend fun finish(ctx: WizardContext) {
        // no-op by default, can be overridden if needed
    }

    // Helper methods for current step tracking via inputListener
    // Bot is passed from context, not stored in engine
    protected fun getCurrentStep(user: User, bot: TelegramBot): WizardStep? {
        val stepId = bot.inputListener
            .get(user.id)
            ?.takeIf { it.startsWith("${getWizardId()}:") }
            ?.substringAfterLast(":")
            ?: return null
        return steps.find { it.id == stepId }
    }

    protected fun setCurrentStep(user: User, bot: TelegramBot, step: WizardStep) {
        bot.inputListener.set(user.id, "${getWizardId()}:${step.id}")
    }

    protected fun clearCurrentStep(user: User, bot: TelegramBot) {
        bot.inputListener.del(user.id)
    }
}
