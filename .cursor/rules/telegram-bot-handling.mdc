---
description: Activity, WizardActivity, functional DSL vs annotation approach, and update handling pipeline
globs: "**/core/**/*.kt", "**/types/chain/**/*.kt", "**/utils/common/FunctionalDSLUtils.kt"
alwaysApply: false
---

# Telegram Bot Handling Architecture

## Activity

[Activity.kt](telegram-bot/src/commonMain/kotlin/eu/vendeli/tgbot/core/Activity.kt) is the interface for all handler functions.

- **id**: Unique identifier (hash of signature)
- **qualifier**: Qualified class name (or "functional" for DSL)
- **function**: Handler name
- **invoke(context)**: Runs the handler with ProcessingContext

**LambdaActivity**: Runtime implementation used by FunctionalHandlingDsl. Wraps a suspend lambda.

**KSP-generated Activity**: Classes generated by ktnip from annotated functions; same interface.

## WizardActivity

[WizardActivity.kt](telegram-bot/src/commonMain/kotlin/eu/vendeli/tgbot/types/chain/WizardActivity.kt) extends Activity for multi-step wizard flows.

- **Abstract**: Concrete implementations generated by KSP from `@WizardHandler` classes
- **steps**: List of WizardStep; order defines flow
- **start(ctx)**: Enters initial step, sets inputListener
- **handleInput(ctx)**: Validates input, applies Transition (Next, JumpTo, Retry, Finish), persists state via WizardStateManager
- **getStateManagerForStep(step, bot)**: Resolves state manager for step's store() return type

**WizardStep**: `onEntry`, `validate` -> Transition, `store` (optional), `onRetry`

**WizardContext**: user, update, bot; `getState`/`setState`/`delState` for step state (type-safe accessors generated by KSP).

## Functional DSL vs Annotation Approach

Both approaches produce **Activity** instances and register them in **ActivityRegistry**. Same pipeline processes them.

### Functional DSL

- **Entry**: `bot.setFunctionality { }` or `bot.handleUpdates()` with functional block
- **FunctionalHandlingDsl**: `onCommand`, `onInput`, `inputChain`, `common`, `onUpdate`, `whenNotHandled`
- **Creates**: LambdaActivity at runtime; registers via `registry.registerActivity`, `registerCommand`, `registerInput`, etc.
- **FunctionalDSLUtils**: `onMessage`, `onCallbackQuery`, etc. — typed wrappers over `onUpdate(UpdateType.X)` for better `ActivityCtx<MessageUpdate>` inference

### Annotation Approach (ktnip)

- **Entry**: `bot.handleUpdates()` loads KtGramCtxLoader (META-INF/services)
- **Collectors**: CommandCollector, InputCollector, CommonCollector, UpdateHandlerCollector, WizardCollector, UnprocessedHandlerCollector
- **Creates**: KSP-generated Activity classes; load() calls `registry.registerActivity`, `registerCommand`, etc.
- **Annotations**: `@CommandHandler`, `@InputHandler`, `@CommonHandler`, `@UpdateHandler`, `@WizardHandler`, `@UnprocessedHandler`

### Shared Flow

1. Update arrives -> ProcessUpdate.processUpdate() -> ProcessedUpdate
2. ProcessingPipeline: Setup -> Parsing -> Match -> Validation -> PreInvoke -> Invoke -> PostInvoke
3. **DefaultMatchInterceptor**: Resolves activity via commands, inputs (inputListener), common handlers
4. **DefaultInvokeInterceptor**: Runs update-type handlers first; then matched activity or unprocessed handler

## ActivityRegistry

- **commands**: UpdateType -> Command -> ActivityId
- **inputs**: InputId -> ActivityId (inputListener stores "wizard:id:step" or plain id)
- **commonHandlers**: UpdateType -> List(CommonMatcher, ActivityId)
- **updateTypeHandlers**: UpdateType -> List(ActivityId) — run for every update of that type
- **unprocessed**: Fallback ActivityId
